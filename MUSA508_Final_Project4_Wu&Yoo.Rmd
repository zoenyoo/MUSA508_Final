---
title: 'Modeling for New Jersey Transit Train Delay'
author: "Jasmine Siyu Wu & Zoe Yoo"
date: "12/17/2021"
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: hide
  ioslides_presentation:
    self-included: yes
---


<br />


## 1. Introduction & Use Case

  For our project, we chose to estimate and model delays in the New Jersey Transit system. Our use case is to develop a tool for the NJ Transit app, specifically the Trip Planner tool, to let customers know which trains might be delayed.  

  New Jersey Transit and Amtrak both serve as commuter rail between Philadelphia, New Jersey, and New York. As Amtrak runs alongside, and is a competitor for, NJ Transit, we originally planned to also develop a website add-on for people buying their train tickets in advance. However, in the Kaggle dataset we use, the Amtrak data only includes actual departure times, not schedule times, which left us without any information on delay for Amtrak trains. 

  New Jersey Transit has a different ticketing system than Amtrak: tickets are only sold through the NJ Transit mobile app or in person, at stations. Additionally, its ticket prices do not fluctuate like Amtrak tickets, which vary based on date of reservation; there is no limit to the number of tickets sold, and one-way tickets have no expiry date. Due to these differences, predicting delay far in advance is not as important for our project, as people can buy tickets as-needed, even on the day of travel, without an influence in pricing. 
  
  So, we decided to conceptualize a tool for the New Jersey Transit App, and in particular, its Trip Planner feature. This tool is not geared towards ticket purchases, but for the convenience of customers who are planning when to take their trips. In the app's Trip Planner, users currently choose an origin and destination station, a date and time, and a factor to minimize (for example, travel time or walking distance). It then returns the schedule options available for that date and time.

  In this "Trip Options" screen, we aim to add an indicator for possible delay for each schedule option available, that refers to the total predicted time delay for each trip. Yellow indicates 10-19 minutes combined predicted delay, orange for 20-29 minutes, and red for over 30 minutes. There is no indicator for under 10 minutes, as we consider that to be an acceptable level of delay. In the Detailed Trip View, we would also add the same icons and categorization color scheme for each leg of a trip.
  
<br />
  
```{r images, echo=FALSE, out.width="33%", out.height="20%", fig.cap="Fig 1.1 Example App Screen",fig.show='hold',fig.align='center'}

# functions and data directory
root.dir = "https://github.com/zoenyoo/MUSA508_Final.git"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

knitr::include_graphics(c("images/sc1.png","images/sc2.png","images/sc3.png"))
knitr::opts_chunk$set(echo = TRUE,fig.width = 10, fig.height = 5, warning = FALSE, message = FALSE)


options(scipen=999) 
options(tigris_class = "sf")
options(tigris_use_cache = TRUE)
options(knitr.duplicate.label = "allow")


```


```{r setup, include=TRUE, warning=FALSE,  message = FALSE, results=FALSE}

#Loading Libraries
library(tidyverse)
library(sf)
library(spdep)
library(caret)
library(ckanr)
library(riem)
library(lubridate)
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot)
library(kableExtra)
library(jtools)     # for regression model plots
library(ggstance)
library(osmdata)
library(knitr)
library(tidycensus)
library(scales)
library(stargazer)
library(ggplot2)
library(ggpubr)
library(xtable)
library(ggmap)
library(leaflet)
library(expss)


#Loading Styling Options
mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.text.x = element_text(size = 14))
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    plot.background = element_blank(),
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    strip.text.x = element_text(size = 14)
  )
}

#Loading Quantile Break Functions
qBr <- function(df, variable, rnd) {
 if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                 c(.01,.2,.4,.6,.8), na.rm=T))
 } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]],
                 c(.01,.2,.4,.6,.8), na.rm=T), digits = 3))
 }
}


q5 <- function(variable) {as.factor(ntile(variable, 5))}

#Loading Hexadecimal Color Palette

palette5 <- c("#324376", "#586ba4", "#f5dd90", "#ee964b", "#f95738")
palette4 <- c("#324376", "#586ba4", "#ee964b", "#f95738")
palette2 <- c("#324376", "#f95738")

```

<br />

<br />

## 2. Data Wrangling

The Kaggle data originally is build up of basic identification data, then spatial and temporal data, broken down below.

```{r data structure images, echo=FALSE, out.width="100%", out.height="100%", fig.cap="Fig 2.0 Data Structure",fig.show='hold',fig.align='center'}

knitr::include_graphics(c("images/table.jpg"))

```
<br />

### 2.1. Import Rail Delay Data

Rail delay data is sourced from [**NJ Transit + Amtrak (NEC) Rail Performance**](https://www.kaggle.com/pranavbadami/nj-transit-amtrak-nec-performance?select=2018_11.csv)

```{r rail delay data,  message = FALSE, warning = FALSE, fig.align='center'}

# January for training and 2-3 weeks in February for testing
rail_2020_01 <- read.csv(unz('Data/2020_01.csv.zip','2020_01.csv'), header = T)
rail_2020_02 <- read.csv(unz('Data/2020_02.csv.zip','2020_02.csv'), header = T)


rail_all <- rbind(rail_2020_01, rail_2020_02) %>%
  mutate(schedule60 = floor_date(ymd_hms(scheduled_time), unit = "hour"),
         actual60 = floor_date(ymd_hms(actual_time), unit = "hour"),
         week = week(schedule60),
         dotw = wday(schedule60, label=TRUE),
         year = year(schedule60),
         month = month(schedule60)) %>%
  drop_na(delay_minutes)
  #filter(week %in% c(14:18)) 

remove(rail_2020_01)
remove(rail_2020_02)


rail_cancelled <- subset(rail_all, status == "cancelled")
rail <- subset(rail_all, status != "cancelled")

summary_statistics <- 
  cbind(" " = list( "mean", "median", "min", "max"),
        "Delay_minutes" = list( "mean" = round(mean(rail$delay_minutes), digits=3),
                                "median" = round(median(rail$delay_minutes), digits=3),
                                "min" = round(min(rail$delay_minutes), digits=3),
                                "max" = round(max(rail$delay_minutes), digits=3)),
        "Dalay_hours" = list("mean" = round(mean(rail$delay_minutes/60), digits=3),
                             "median" =  round(median(rail$delay_minutes/60), digits=3),
                             "min" =  round(min(rail$delay_minutes/60), digits=3),
                             "max" =  round(max(rail$delay_minutes/60), digits=3))) %>% 
  as_data_frame() 

summary_statistics %>% 
  kable(digits=2, caption="Table 2.1 Summary statistics of delay time at all recorded station stops - Jan.-Feb. 2020") %>% 
  kable_styling()
```

Before developing a model, we examine the data to determine whether delay in the NJ Transit system happens often enough and is severe enough to warrant our tool. As can be seen in Figures 2.1 and 2.2, most trains in our sample set are delayed under ten minutes, with frequency reaching very  low levels for delay over 40 minutes, and even less for over an hour.

```{r rail delay histogram,  message = FALSE, warning = FALSE, fig.align='center', fig.width=10}
ggplot(rail)+
  geom_histogram(aes(delay_minutes), binwidth = 0.5, fill = palette2[2], alpha=0.8)+
  #xlim(0, 100) +
  labs(title="New Jersey Transit Rail Delay at All Stops",
       subtitle = "Jan.-Feb. 2020",
       x="Minutes", 
       y="Frequency",
       caption="Figure 2.1")+
  plotTheme()
```


```{r rail delay histogram break,  message = FALSE, warning = FALSE, fig.align='center', fig.width=15}
ggarrange(ncol=3,
          ggplot(subset(rail, delay_minutes<=10))+
            geom_histogram(aes(delay_minutes), binwidth = 0.5, fill = palette2[2], alpha=0.8)+
            #xlim(0, 100) +
            labs(x="Minutes", 
                 y="Frequency",
                   title="Delay Time of Trains at All Stops, Jan-Feb 2020",
                   subtitle="within 10 minutes",
                 caption="Figure 2.2")+
            plotTheme(),
            ggplot(subset(rail, delay_minutes<=60 & delay_minutes > 10))+
              geom_histogram(aes(delay_minutes), binwidth = 0.5, fill = palette2[2], alpha=0.8)+
              #xlim(0, 100) +
              labs(x="Minutes", 
                   y="Frequency",
                   title=" ",
                   subtitle="10 minutes - 1 hour",
                   caption=" ")+
              plotTheme(),
            ggplot(subset(rail, delay_minutes > 60))+
              geom_histogram(aes(delay_minutes), binwidth = 0.5, fill = palette2[2], alpha=0.8)+
              #xlim(0, 100) +
              labs(x="Minutes", 
                   y="Frequency",
                   title=" ",
                   subtitle="over 1 hour",
                   caption="")+
              plotTheme())

```

<br />

### 2.2. Import Weather Data

Through the RIEM package, we import weather data to integrate into the modeling. There are three types of weather data available: precipitation, wind speed, and temperature. As trains are not affected by temperature the same way other modes of transportation might be (i.e. walking or cycling), it is most likely the least influential of our weather data. Precipitation generally would not delay service outside of extreme storms, in which snow buildup or mudslides might make tracks unusable; wind speed is similar, but has the potential to contribute to factors like blown-over trees. 


```{r weather data,  message = FALSE, warning = FALSE, fig.align='center', fig.width=8, fig.height=6}

#https://mesonet.agron.iastate.edu/request/download.phtml?network=CA_ASOS
# EWR station is at Newark International Airport
weather.Data <- 
  riem_measures(station = "EWR", date_start = "2020-01-01", date_end = "2020-03-01") 



weather.Panel <-  
  weather.Data %>%
    mutate_if(is.character, list(~replace(as.character(.), is.na(.), "0"))) %>% 
    replace(is.na(.), 0) %>%
    mutate(interval60 = ymd_h(substr(valid, 1, 13))) %>%
    mutate(week = week(interval60),
           dotw = wday(interval60, label=TRUE)) %>%
    group_by(interval60) %>%
    summarize(Temperature = max(tmpf),
              Percipitation = sum(p01i),
              Wind_Speed = max(sknt)) %>%
    mutate(Temperature = ifelse(Temperature == 0, 42, Temperature))

remove(weather.Data)

grid.arrange(bottom="Figure 2.3 Weather Data, New Jersey, January - February, 2020",
  ggplot(weather.Panel, aes(interval60, Percipitation)) +
    geom_line(color = palette2[2]) + 
    labs(title="Precipitation", x="Hour", y="Precipitation (in.)") + 
    plotTheme(),
  ggplot(weather.Panel, aes(interval60, Wind_Speed)) + 
    geom_line(color = palette2[2]) + 
    labs(title="Wind Speed", x="Hour", y="Wind Speed (mph)") + 
    plotTheme(),
  ggplot(weather.Panel, aes(interval60, Temperature)) + 
    geom_line(color = palette2[2]) + 
    labs(title="Temperature", x="Hour", y="Temperature (F)") + 
    plotTheme())
```

<br />

### 2.3. Import Station and Place Boundary Data

To integrate spatial data, we download the locations of NJ Transit stations, as well as additional county-level geographies.

```{r station data,  message = FALSE, warning = FALSE, results = FALSE, fig.align='center'}
station.sf <- st_read("https://opendata.arcgis.com/datasets/4809dada94c542e0beff00600ee930f6_0.geojson") %>%
  st_transform("EPSG:3424") %>% #NAD83 / New Jersey (ftUS) 
  rename(STATION_NAME = STATION_ID)

station_list <- read.csv('Data/StationName_ID.csv', header = T)
station.sf <- left_join(station.sf, station_list, by=c("STATION_NAME" = "STATION_NAME"))


# mainly New Jersey yet a few in New York State and Penn
counties <- rbind(get_acs(geography = "county", 
                        year = 2019,
                        state = 34, 
                        variables = (TotalPop = 'B01001_001E'),
                        survey = "acs5",
                        output = "wide",
                        geometry = TRUE),
                get_acs(geography = "county", 
                        year = 2019,
                        state = 42, 
                        variables = (TotalPop = 'B01001_001E'),
                        survey = "acs5",
                        output = "wide",
                        geometry = TRUE),
                get_acs(geography = "county", 
                        year = 2019,
                        state = 36,
                        variables = (TotalPop = 'B01001_001E'),
                        survey = "acs5",
                        output = "wide",
                        geometry = TRUE)) %>% 
  st_transform(st_crs(station.sf)) 
 
intersect.counties <-  subset(counties, GEOID %in% 
                              (st_intersection(counties, station.sf) %>%
                                 dplyr::select(GEOID) %>%
                                 st_drop_geometry() %>%
                                 unique())$GEOID)

rm(counties)

states <- rbind(get_acs(geography = "state", 
                        year = 2019,
                        state = 34, 
                        variables = (TotalPop = 'B01001_001E'),
                        survey = "acs5",
                        output = "wide",
                        geometry = TRUE),
                get_acs(geography = "state", 
                        year = 2019,
                        state = 42, 
                        variables = (TotalPop = 'B01001_001E'),
                        survey = "acs5",
                        output = "wide",
                        geometry = TRUE),
                get_acs(geography = "state", 
                        year = 2019,
                        state = 36,
                        variables = (TotalPop = 'B01001_001E'),
                        survey = "acs5",
                        output = "wide",
                        geometry = TRUE)) %>% 
  st_transform(st_crs(station.sf)) 

```

The spatial extent of the NJ Transit rail system is plotted below; while most stations are in New Jersey, there is also one in Philadelphia and three in New York. 

```{r station plot,  message = FALSE, warning = FALSE, fig.width=8, fig.align='center'}
# ggplot() +
#   geom_sf(data=intersect.counties, color='grey', fill=NA) +
#   geom_sf(data=station.sf, color=palette2[1], alpha=0.8, size=1) +
#   labs(title="New Jersey Transit and Amtrak Stations",
#        caption = "Figure 2.1") +
#   mapTheme() 

station.sf %>% st_transform(crs = 4326) %>%
  st_coordinates() %>% leaflet() %>% addProviderTiles("Thunderforest.Landscape") %>% addProviderTiles("Stamen.TonerHybrid") %>% addMarkers(icon = list(iconSize = c(0.5, 0.5)))
```

<br />

### 2.4. Create Space-Time Panel and Time Lags

To test the effect of time lag, we calculate time lag values for periods of twelve hours up to seven days.

```{r bike panel,  message = FALSE, warning = FALSE}
rail.template <- rail %>%
  semi_join(st_drop_geometry(station.sf),
            by = c( "to_id" = "STATION_ID"))

#length(unique(rail.template$schedule60)) * length(unique(rail.template$to_id))

study.panel <-
  expand.grid(schedule60 = unique(rail.template$schedule60),
              to_id = unique(rail.template$to_id))

#nrow(study.panel)


rail.panel <-
  rail.template %>%
    mutate(Train_Counter = 1) %>%
    right_join(study.panel) %>%
      group_by(schedule60, to, to_id) %>%
      summarize(Train_Count = sum(Train_Counter, na.rm=T),
                mean_delay_minutes = mean(delay_minutes, na.rm=T)) %>%
      left_join(weather.Panel, by = c( "schedule60" = "interval60")) %>%
        left_join(station.sf, by = c( "to_id" = "STATION_ID")) %>%
          mutate(week = week(schedule60),
                 dotw = wday(schedule60, label = TRUE)) # %>% st_sf()


rail.panel <-
  rail.panel %>%
    arrange(STATION_NAME, schedule60) %>%
    group_by(STATION_NAME) %>%
    mutate(lag12Hours = dplyr::lag(mean_delay_minutes,12),
           lag1day = dplyr::lag(mean_delay_minutes,24),
           lag2day = dplyr::lag(mean_delay_minutes,48),
           lag3day = dplyr::lag(mean_delay_minutes,72),
           lag4day = dplyr::lag(mean_delay_minutes,96),
           lag5day = dplyr::lag(mean_delay_minutes,120),
           lag6day = dplyr::lag(mean_delay_minutes,144),
           lag7day = dplyr::lag(mean_delay_minutes,168)) %>%
   ungroup()

```

<br />

<br />


## 3. Exploratory Analysis

First, we look at the general punctuality rate of trains for all stops; most trains arrive within an acceptable time frame, or under 10 minutes of delay, with only about 3% of stops seeing delays of over 20 minutes.

```{r ppm data,  message = FALSE, warning = FALSE}

ppm_summary <- data_frame(var = c("all_pp5", "all_pp10", "all_pp20"), 
                          val = c(
                                 round(nrow(subset(rail, delay_minutes<5))/nrow(rail)*100, digits=2),
                                 round(nrow(subset(rail, delay_minutes<10))/nrow(rail)*100, digits=2),
                                 round(nrow(subset(rail, delay_minutes<20))/nrow(rail)*100, digits=2)))

ppm_summary[,2] %>%  
  `rownames<-`(., c("Arrived within 5 minutes", "Arrived within 10 minutes",
                    "Arrived within 20 minutes")) %>% 
  kable(col.names = c("Percentage of trains"), 
        caption="Table 3.1 Punctuality rate of all stops (Jan.- Feb. 2020)") %>% 
  kable_styling()

```

To further examine delay, we used two metrics from the UK Southern Railway's [train service punctuality and reliability measures
](https://www.southernrailway.com/about-us/how-were-performing/train-service-punctuality-and-reliability); the first, "on time," considers the percentage of trains that arrive at each stop on schedule. For New Jersey Transit, the on-time rate of trains is usually low, with most trains only reaching each stop at its scheduled time 10-20% of the time.

```{r on time rate plots,  message = FALSE, warning = FALSE, fig.width=10}
station.sf <- rail %>% group_by(to_id) %>%
    summarise(train_count = n(),
              mean_delay_minutes = mean(delay_minutes),
              on_time_rate = count_if(0, delay_minutes)/train_count,
              ppm_5 = count_if(lt(5), delay_minutes)/train_count,
              ppm_10 = count_if(lt(10), delay_minutes)/train_count,
              ppm_20 = count_if(lt(20), delay_minutes)/train_count) %>% 
    right_join(station.sf, by = c( "to_id" = "STATION_ID")) %>%  
    st_sf() %>%
    st_transform(crs = 4326) 



ggplot(as.data.frame(station.sf))+
            geom_histogram(aes(on_time_rate), binwidth = 0.05, fill = palette2[2], alpha=0.8)+
            #xlim(0, 100) +
            labs(x="On time rate", 
                 y="Frequency",
                   title="On-Time Rate of Trains by New Jersey Transit Station",
                   subtitle="Jan-Feb 2020",
                 caption="Figure 3.1")+
            plotTheme()
```

The second indicator is the "Public Performance Measure (PPM)," which refers to the percentage of trains that arrive at their stops within 5 minutes. Even using different brackets for PPM, it is clear that PPM varies spatially (and is especially low on the Philly-Atlantic City line). So, we concluded that there are sufficient delays within the system to warrant modeling.

```{r ppm plots,  message = FALSE, warning = FALSE, fig.width=15}
ggarrange(ncol=3,
    ggplot() +
      geom_sf(data=intersect.counties, color='grey', fill=NA) +
      geom_sf(data=na.omit(station.sf), aes(color=ppm_5), size=2) +
        scale_color_gradient(high = "#FFFFFF", low = palette5[5],
                             name="PPM 5 minutes") + 
      labs(title="Punctuality Rate of Trains by Station",
           subtitle="Jan-Feb 2020",
           caption = "Figure 3.2") +
      mapTheme(),
    ggplot() +
      geom_sf(data=intersect.counties, color='grey', fill=NA) +
      geom_sf(data=na.omit(station.sf), aes(color=ppm_10), size=2) +
        scale_color_gradient(high = "#FFFFFF", low = palette5[5],
                             name="PPM 10 minutes") + 
      labs(title=" ",
           subtitle=" ",
           caption = " ") +
      mapTheme(),
    ggplot() +
      geom_sf(data=intersect.counties, color='grey', fill=NA) +
      geom_sf(data=na.omit(station.sf), aes(color=ppm_20), size=2) +
        scale_color_gradient(high = "#FFFFFF", low = palette5[5],
                             name="PPM 20 minutes") + 
      labs(title=" ",
           subtitle=" ",
           caption = " ") +
      mapTheme())

```

By comparing stops per hour to delay per hour for all stations, we can see that there is no inherent pattern to high delay in relation to the number of stops per hour, except that the highest spikes of delay do occur during periods of more stops per hour.

```{r rail trip timeseries,  message = FALSE, warning = FALSE, fig.width=12, fig.height=8}

grid.arrange(
  ggplot(rail %>%
           group_by(schedule60) %>%
           tally())+
    geom_line(aes(x = schedule60, y = n), color = palette2[1])+
    labs(title="Total Train Stops per Hour of All NJ Transit Stations",
         subtitle="Jan. - Feb., 2020",
         x="Date", 
         y="Total Train Stops",
         caption="Figure 3.3")+
    plotTheme(),
  ggplot(rail %>%
           group_by(schedule60) %>%
           summarise(mean_delay_minutes = mean(delay_minutes)))+
           #tally())+
    geom_line(aes(x = schedule60, y = mean_delay_minutes), color = palette2[2])+
    labs(title="Average Delay Time per Hour of All NJ Transit Stations",
         subtitle="Jan. - Feb., 2020",
         x="Date", 
         y="Average delay minutes",
         caption="Figure 3.4")+
    plotTheme())

```

From Figure 3.6, we notice there are some time processes of train delay by day of the week and time of the day, so we engineer new variables of each train record: `weekday` and `time_of_day`.

```{r day of week, message = FALSE, warning = FALSE, fig.height=8, fig.width=10}
grid.arrange(
  ggplot(rail)+
       geom_freqpoly(aes(hour(schedule60), color = dotw), binwidth = 1)+
       xlim(0, 24)+
       labs(title="Total rail stops of New Jersey Transit",
            subtitle = "New Jersey, Jan. - Feb., 2020",
            x="Hour", 
            y="Rail Stop Counts", caption = "Figure 3.5")+
       plotTheme(),
  ggplot(rail %>% mutate(hour=hour(schedule60)) %>%
         group_by(hour, dotw) %>%
         summarise(mean_delay_minutes = mean(delay_minutes)))+
       geom_line(aes(x=hour, y=mean_delay_minutes, color = dotw), binwidth = 1)+
       xlim(0, 24)+
       labs(title="Average delay time per hour of New Jersey Transit",
            subtitle = "New Jersey, Jan. - Feb., 2020",
            x="Hour", 
            y="Average Delay Minutes", caption = "Figure 3.6")+
       plotTheme())

rail <- rail %>%
  mutate(hour = hour(schedule60),
         time_of_day = case_when(hour < 7 | hour > 22 ~ "Overnight",
                                 hour >= 7 & hour < 11 ~ "Morning",
                                 hour >= 11 & hour < 13 ~ "Noon",
                                 hour >= 13 & hour < 17 ~ "Afternoon",
                                 hour >= 17 & hour <= 22 ~ "Night"),
         weekday = case_when(dotw %in% c("Mon", "Tue", "Wed", "Thu", "Fri") ~ "Weekday",
                             dotw %in% c("Sat", "Sun")  ~ "Weekend"))
```

There are relationships between delay and time lag delay, as shown in the scatter plots in Figure 3.7. We will consider these time lags as independent variables in the following modeling part. 

```{r correlation_lag, cache = TRUE, message = FALSE, warning = FALSE, fig.height=4, fig.width=12}
plotData.lag <-
  as.data.frame(rail.panel) %>% drop_na(mean_delay_minutes) %>%
  group_by(schedule60) %>%
  summarise_at(c("lag12Hours","lag1day",
               "lag2day", "lag3day", 
               "lag4day", "lag5day", 
               "lag6day", "lag7day", "mean_delay_minutes"), mean, na.rm = TRUE) %>%
   dplyr::select(starts_with("lag"), mean_delay_minutes) %>%
  gather(Variable, Value, -mean_delay_minutes) %>%
  mutate(Variable = factor(Variable, levels=c("lag12Hours","lag1day",
                                              "lag2day", "lag3day", 
                                              "lag4day", "lag5day", 
                                              "lag6day", "lag7day")))
         
correlation.lag <- plotData.lag %>% 
  drop_na(Value) %>%
  group_by(Variable) %>%
  summarize(correlation = round(cor(Value, mean_delay_minutes, use = "complete.obs"), 2)) 



ggplot(data=plotData.lag, aes(Value, mean_delay_minutes)) +
  geom_point(size = .1) +
  geom_smooth(method = 'lm', se = F, color = palette2[2]) +
  geom_text(data = correlation.lag, color=palette2[2],
            aes(label = paste('r =', correlation)),
            x = -Inf, y = Inf, vjust = 1.5, 
            hjust = -.1, size = 5) +
  facet_wrap(~Variable, ncol=8) +
  labs(title = 'Train Delay Time as a Function of Time Lags', 
       x = 'Lag Mean Delay (min)',
       y = 'Mean Delay (min)',
       caption = "Figure 3.7") +
  plotTheme()

```

<br />

<br />


## 4. Modeling and Validation



<br />

### 4.1 Preparing Train and Test Sets

For our models, we train on the first five weeks of our dataset and test on the last three (see Figure 4.1). 

```{r serial_correlation, cache = TRUE, message = FALSE, warning = FALSE, fig.width=10, fig.height=3}
mondays <- 
  mutate(rail,
         monday = ifelse(dotw == "Mon" & hour == 0,
                         schedule60, 0)) %>%
  filter(monday != 0) 

rail <- rail %>% 
  left_join(as_data_frame(rail.panel) %>% 
           dplyr::select(to_id, schedule60,
                         LATITUDE, LONGITUDE, 
                         Temperature, Percipitation, Wind_Speed,
                         lag12Hours,lag1day,lag2day, lag3day, 
                         lag4day, lag5day, lag6day, lag7day, mean_delay_minutes),  
           by=c("to_id" = "to_id", "schedule60" = "schedule60")) %>%
  rename(to_lag12Hours = lag12Hours, to_lag1day = lag1day,
         to_lag2day = lag2day, to_lag3day = lag3day,
         to_lag4day = lag4day, to_lag5day = lag5day,
         to_lag6day = lag6day, to_lag7day = lag7day,
         to_mean_delay_minutes = mean_delay_minutes) %>%
  left_join(as_data_frame(rail.panel) %>%
            dplyr::select(lag12Hours,lag1day,lag2day, lag3day,
                         lag4day, lag5day, lag6day, lag7day,
                         mean_delay_minutes, to_id, schedule60),
           by=c("from_id" = "to_id", "schedule60" = "schedule60")) %>%
  rename(from_lag12Hours = lag12Hours, from_lag1day = lag1day,
         from_lag2day = lag2day, from_lag3day = lag3day,
         from_lag4day = lag4day, from_lag5day = lag5day,
         from_lag6day = lag6day, from_lag7day = lag7day,
         from_mean_delay_minutes = mean_delay_minutes)


rail.Train <- filter(rail, week < 6)
rail.Test <- filter(rail, week >= 6 & week < 9)


rbind(mutate(rail.Train, Legend = "Training"), 
      mutate(rail.Test, Legend = "Testing")) %>%
    group_by(Legend, schedule60) %>% 
      summarise(mean_delay_minutes = mean(delay_minutes)) %>%
      ungroup() %>% 
      ggplot(aes(schedule60, mean_delay_minutes, colour = Legend)) + geom_line() +
        scale_colour_manual(values = palette2) +
        geom_vline(data = mondays, aes(xintercept = monday)) +
        labs(title="NJ Transit Rail Trips by Week",
             subtitle="January-February 2021",
             x="Day", y="Mean Delay Minutes",
             caption = "Figure 4.1") +
        plotTheme() + 
        theme(panel.grid.major = element_blank())    
```

<br />

### 4.2 Run Models

We have developed four different models with increasing levels of detail. 

- Model A. Time: `hour` + `dotw` + `Temperature` + `Percipitation`

- Model B. Space: `from` + `to` + `line` + `dotw` + `Temperature` + `Percipitation`

- Model C. Time Space: `from` + `to` + `line` + `hour` + `dotw` + `Temperature` + `Percipitation`

- Model D. Time Space Timelag: `from` + `to` + `stop_sequence` + `line` + `hour` + `time_of_day` + `weekday` + `dotw` + `Temperature` + `Percipitation` + `to_lag12Hours` + `to_lag1day` + `to_lag7day` + `from_lag12Hours` + `from_lag1day` + `from_lag7day`

<br />

As can be seen in Table 4.1, the fourth model has the highest adjusted $R^{2}$s value, so we will continue to test with this model.

```{r train_test, message = FALSE, warning = FALSE, results="asis"}
reg1 <- 
  lm(delay_minutes ~  hour + dotw + Temperature + Percipitation,  data=rail.Train)

reg2 <- 
  lm(delay_minutes ~  from + to + line + dotw + Temperature + Percipitation,  data=rail.Train)

reg3 <-
  lm(delay_minutes ~  from + to + line + hour + dotw + Temperature + Percipitation,  data=rail.Train)

reg4 <-
  lm(delay_minutes ~  from + to + stop_sequence + line + hour + time_of_day + weekday + dotw + Temperature + Percipitation + 
       to_lag12Hours + to_lag1day + to_lag7day + from_lag12Hours + from_lag1day + from_lag7day,  data=rail.Train)


# stargazer(reg1, reg2, reg3, reg4, digits=3,
#           type="html", title="Table 4.1 Regression results",
#           single.row=TRUE,
#           column.labels=c("A. Time", "B. Space",
#                           "C. Time Space",
#                           "D. Time Space Timelag",
#                           "E. Time Space Timelag Transit"))


omitList <- append(names(reg1$coefficients),
                   append(names(reg2$coefficients), 
                          append(names(reg4$coefficients), names(reg3$coefficients)))) %>% 
            unique()

stargazer(reg1, reg2, reg3, reg4, type="html", star.cutoffs = c(0.05, 0.01, 0.001), 
          median=TRUE, title="Table 4.1 Training Set Baseline Regression Results (Hide independent variables)", align=TRUE,
          column.labels = c("A. Time", "B. Space", "C. Time Space", "D. Time Space Timelag"),
          single.row=TRUE, digits=2, omit = append(omitList, c("dotw4", "dotw5", "dotw6")))


summary(reg4) %>%
  xtable() %>%
  kable(align='c', caption="Table 4.2 Independent Variables in Model D",
        digits=2) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "300px")

```



<br />


### 4.3. Predict for Test Data

```{r predict_for_test, warning = FALSE, message = FALSE}
# nest data
rail.Test.weekNest <- 
  subset(rail.Test, 
         !from %in% c("Lake Hopatcong", "Lindenwold", "Middletown NY", 
                      "North Elizabeth", "Princeton Junction", 
                      "South Orange", "Secaucus Concourse") & 
           !to %in% c("Lake Hopatcong", 
                      "Lindenwold", "Middletown NY", 
                      "North Elizabeth", "Princeton Junction", 
                      "South Orange", "Secaucus Concourse")) %>% 
  group_by(week) %>%
  tidyr::nest()
  #nest(-week)

# predict function
model_pred <- function(dat, fit){
   pred <- predict(fit, newdata = dat)}


# do predictions
week_predictions <- 
  rail.Test.weekNest %>% 
    mutate(ATime_FE = map(.x = data, fit = reg1, .f = model_pred),
           BSpace_FE = map(.x = data, fit = reg2, .f = model_pred),
           CTime_Space_FE = map(.x = data, fit = reg3, .f = model_pred),
           DTime_Space_FE_timeLags = map(.x = data, fit = reg4, .f = model_pred)) %>% 
    gather(Regression, Prediction, -data, -week) %>%
    mutate(Observed = map(data, pull, delay_minutes),
           Absolute_Error = map2(Observed, Prediction,  ~ abs(.x - .y)),
           MAE = map_dbl(Absolute_Error, mean, na.rm = TRUE),
           sd_AE = map_dbl(Absolute_Error, sd, na.rm = TRUE))

```

<br />

### 4.4. Validate Test Set by Time and Space

In Figure 4.2, it is clear that mean absolute error (MAE) is also the least for the fourth, most detailed model. 

```{r plot_errors_by_model, warning = FALSE, message = FALSE, fid.width=10}
# week_predictions <- week_predictions %>%  
#     gather(Regression, Prediction, -data, -week) %>% 
#     mutate(Observed = map(data, pull, Trip_Count),
#            Absolute_Error = map2(Observed, Prediction,  ~ abs(.x - .y)),
#            MAE = map_dbl(Absolute_Error, mean),
#            sd_AE = map_dbl(Absolute_Error, sd))


week_predictions %>% 
  dplyr::select(Regression, MAE, week) %>%  
  gather(Variable, MAE, -Regression, -week) %>% 
  ggplot(aes(week, MAE)) + 
    geom_bar(aes(fill = Regression), position = "dodge", stat="identity") +
    scale_fill_manual(values = palette5) +
    labs(title = "Mean Absolute Errors (MAE) by model specification and week",
         caption="Figure 4.2") +
  plotTheme()
```

When testing the prediction models on the last three weeks of data, a few notable effects emerge (see Figure 4.3). The time and space model, which combines temporal, spatial, and weather data, predicts fairly accurately for general trends and spikes of low delay, but misses most short periods of high delay. With the fourth model, that adds time lag, the model clearly attempts to replicate spikes of high delay based on those present in previous data; however, the exact dates for high delay occurrences are not predicted accurately, presumably because there are additional variables contributing to specific events.

```{r error_vs_actual_timeseries, warning = FALSE, message = FALSE, fig.width=9, fig.height=6}
week_predictions %>%  
  mutate(schedule60 = map(data, pull, schedule60),
         to = map(data, pull, to)) %>%
  dplyr::select(schedule60, to, Observed, Prediction, Regression) %>%
  unnest() %>%
  gather(Variable, Value, -Regression, -schedule60, -to, -week) %>% drop_na() %>%
    group_by(Regression, Variable, schedule60) %>%
    summarize(Value = mean(Value)) %>%
    ggplot(aes(schedule60, Value, colour=Variable)) + geom_line(size = 1.1, na.rm = T) + 
      facet_wrap(~Regression, ncol=1) +
      scale_colour_manual(values = palette2) +
      labs(title = "Mean Predicted/Observed train delay minutes by hourly interval", 
           x = "Hour", y= "Mean delay minutes",
           caption = "Figure 4.3") +
      plotTheme()
```

<br />

As shown in Figure 4.4, many stations lack enough information to be predicted so that they display in light grey. Model D performs better in explaining time process than spatial process. In the last session, we will focus on the cross validation by time, which is `day of the week`.

```{r validation_space, cache=TRUE, warning = FALSE, message = FALSE, out.width="100%"}
ggplot()+
  geom_sf(data=intersect.counties, fill="transparent",color = "gray") +
  geom_sf(data = (week_predictions %>% 
                      mutate(schedule60 = map(data, pull, schedule60),
                             to = map(data, pull, to)) %>%
                      dplyr::select(schedule60, to, Observed, Prediction, Regression, -week) %>%
                      unnest(cols = c(schedule60, to, Observed, Prediction)) %>% 
                      #filter(Regression %in% c("DTime_Space_FE_timeLags")) %>%
                      group_by(schedule60, Regression, to) %>%
                      summarize(MAE = mean(abs(Observed-Prediction), na.rm = TRUE))%>%
                      left_join(station.sf, by = c("to" = "STATION_NAME")) %>%
                      st_as_sf()),
             aes(color = MAE, geometry=geometry)) +
  scale_color_gradient(high = "#f95738", low = "#fabbaf", limits = c(0, 0.4), na.value="#f0f0f0") +
  facet_wrap(~Regression, ncol=4) +
  labs(title="Mean Absolute Errors (MAE) of Test Set by Model", 
       #subtitle="4 Regression Models", 
       caption = "Figure 4.4") +
  mapTheme()

```

<br />

### 4.5. Categorical Prediction Accuracy - PPM

As Figure 4.5 shows, `Model D` is generally accurate when predicting trains delayed within 5, 10, and 20 minutes. Especially for puctuality rate of 10 minutes and 20 minutes, `Model D` successfully predict a majority of train delays.

```{r validation ppm plots, cache=TRUE, warning = FALSE, message = FALSE, fig.width=16}

ppm_validation <- week_predictions %>% 
    #mutate(delay_minutes = map(data, pull, delay_minutes)) %>%
    dplyr::select(Observed, Prediction, Regression, -week) %>%
    unnest(cols = c(Observed, Prediction)) %>% 
    filter(Regression %in% c("DTime_Space_FE_timeLags"))  %>%
    mutate(ppm_5 = ifelse(Observed < 5, "1", "0"),
           ppm_10 = ifelse(Observed < 10, "1", "0"),
           ppm_20 = ifelse(Observed < 20, "1", "0"),
           ppm_20plus = ifelse(Observed >= 20, "1", "0"))

ggarrange(ncol=2, nrow=2,
  ggplot(filter(ppm_validation, ppm_5 == "1")) +
      geom_histogram(aes(Prediction), binwidth = 0.5, fill = palette2[2], alpha=0.8, na.rm = TRUE)+
      geom_vline(aes(xintercept = 5), colour=palette2[1], size=0.8) +
      #xlim(0, 100) +
      labs(x="Predicted Delay Minutes", 
           y="Frequency",
           title="Actual delay time within 5 minutes",
           caption=" ")+
      plotTheme(),
  ggplot(filter(ppm_validation, ppm_10 == "1")) +
      geom_histogram(aes(Prediction), binwidth = 0.5, fill = palette2[2], alpha=0.8, na.rm = TRUE)+
      geom_vline(aes(xintercept = 10), colour=palette2[1], size=0.8) +
      #xlim(0, 100) +
      labs(x="Predicted Delay Minutes", 
           y="Frequency",
           title="Actual delay time within 10 minutes",
           caption=" ")+
      plotTheme(),
  ggplot(filter(ppm_validation, ppm_20 == "1")) +
      geom_histogram(aes(Prediction), binwidth = 0.5, fill = palette2[2], alpha=0.8, na.rm = TRUE)+
      geom_vline(aes(xintercept = 20), colour=palette2[1], size=0.8) +
      #xlim(0, 100) +
      labs(x="Predicted Delay Minutes", 
           y="Frequency",
           title="Actual delay time within 20 minutes",
           caption="Figure 4.5")+
      plotTheme(),
  ggplot(filter(ppm_validation, ppm_20plus == "1")) +
      geom_histogram(aes(Prediction), binwidth = 0.5, fill = palette2[2], alpha=0.8, na.rm = TRUE)+
      geom_vline(aes(xintercept =20), colour=palette2[1], size=0.8) +
      #xlim(0, 100) +
      labs(x="Predicted Delay Minutes", 
           y="Frequency",
           title="Actual delay time above 20 minutes",
           caption=" ")+
      plotTheme())

```


Of each actual delay time category, our model successfully captures 57%, 71%, and 73% of delayed trains for categories under 20 minutes, but only 9% of trains with delay over 20 minutes. That is, `Model D` cannot predict almost 90% of trains that delayed over 20 minutes.

```{r ppm validation table, cache=TRUE, warning = FALSE, message = FALSE, fig.width=16}
ppm_accuracy <- data_frame(var = c("Within 5 minutes", "within 10 minutes", "within 20 minutes", "above 20 minutes"), 
                           val = c(
                                   round(nrow(subset(ppm_validation, ppm_5 == "1" & Prediction < 5))/nrow(subset(ppm_validation, ppm_5 == "1"))*100, digits=2),
                                   round(nrow(subset(ppm_validation, ppm_10 == "1" & Prediction < 10))/nrow(subset(ppm_validation, ppm_10 == "1"))*100, digits=2),
                                   round(nrow(subset(ppm_validation, ppm_20 == "1" & Prediction < 20))/nrow(subset(ppm_validation, ppm_20 == "1"))*100, digits=2),
                                   round(nrow(subset(ppm_validation, ppm_20plus == "1" & Prediction >= 20))/nrow(subset(ppm_validation, ppm_20plus == "1"))*100, digits=2)))

ppm_accuracy[,2] %>%  
  `rownames<-`(., c("Arrived within 5 minutes", "Arrived within 10 minutes",
                    "Arrived within 20 minutes", "Arrived above 20 minutes")) %>% 
  kable(col.names = c("Prediction Accuracy Rate"), 
        caption = "Table 4.3 Prediction Accuracy by Delay Time Category") %>% kable_styling()
```


<br />


### 4.6. Cross-Validation

For cross-validation, we train on `day of the week`, cross validating one day against the six other days. In the results from the cross-validation process (shown in Figure 4.6), daily mean absolute error is mostly low, with mean MAE being 0.6 minutes and maximum daily MAE at just under two minutes.

```{r cross validation, warning = FALSE, message = FALSE, fig.width=10, results=FALSE}
ride.panel8week <- rbind(
  mutate(rail.Train, Legend = "Training", hour = hour(schedule60)), 
  mutate(rail.Test, Legend = "Testing", hour = hour(schedule60))) %>%
  subset(!from %in% c("Lake Hopatcong", "Lindenwold", "Middletown NY", 
                      "North Elizabeth", "Princeton Junction", 
                      "South Orange", "Secaucus Concourse") & 
           !to %in% c("Lake Hopatcong", 
                      "Lindenwold", "Middletown NY", 
                      "North Elizabeth", "Princeton Junction", 
                      "South Orange", "Secaucus Concourse"))

reg.vars <-
  c("from", "to", "stop_sequence", "line", "schedule60", "dotw", "Temperature", "Percipitation", 
       "to_lag12Hours", "to_lag1day", "to_lag7day", "from_lag12Hours", "from_lag1day", "from_lag7day")
#start_station

ride.panel8week <-
  ride.panel8week %>%
  left_join(station.sf, by=c("to_id" = "to_id")) %>%
  st_as_sf()



crossValidate <- function(dataset, id, dependentVariable, indVariables) {
  allPredictions <- data.frame()
  cvID_list <- unique(dataset[[id]])
  
  for (i in cvID_list) {
    thisFold <- i
    cat("This hold out fold is", thisFold, "\n")
    
    fold.train <- filter(dataset, dataset[[id]] != thisFold) %>% as.data.frame() %>% 
      dplyr::select(id, indVariables, dependentVariable)
    fold.test  <- filter(dataset, dataset[[id]] == thisFold) %>% as.data.frame() %>% 
      dplyr::select(id, indVariables, dependentVariable)

    regression <-
      glm(delay_minutes ~ ., family = "poisson", 
          data = fold.train %>% 
            dplyr::select(-id))
    
    thisPrediction <- 
      mutate(fold.test, Prediction = predict(regression, fold.test, type = "response"))
    
    allPredictions <-
      rbind(allPredictions, thisPrediction)
  }
  return(allPredictions)
}



# reg.cv <- crossValidate(
#   dataset = ride.panel8week,
#   id = "to_id",
#   dependentVariable = "delay_minutes",
#   indVariables = reg.vars) %>%
#     dplyr::select(start_station = start_station, delay_minutes, Prediction)


reg.cv.time <- crossValidate(
  dataset = ride.panel8week,
  id = "dotw",
  dependentVariable = "delay_minutes",
  indVariables = reg.vars) %>%
    dplyr::select("Day_of_the_Week" = dotw, delay_minutes, Prediction)


# reg.summary.space <-
#   mutate(reg.cv, Error = Prediction - delay_nimutes,
#                  Regression = "Random LOGO CV: Space (Station)")


reg.summary.time <-
  reg.cv.time %>%
  mutate(reg.cv.time, Error = Prediction - delay_minutes,
                      Regression = "Random LOGO CV: Time (Day of the Week)")

```




```{r validation results, warning = FALSE, message = FALSE, fig.width=8}
# error.fold.space <- 
#   reg.summary.space %>%
#     group_by(start_station) %>% 
#     summarize(Mean_Error = mean(Prediction - Trip_Count, na.rm = T),
#               MAE = mean(abs(Mean_Error), na.rm = T),
#               SD_MAE = mean(abs(Mean_Error), na.rm = T)) %>%
#   ungroup()


error.fold.time <- 
  reg.summary.time %>%
    group_by(Day_of_the_Week) %>% 
    summarize(Mean_Error = mean(Prediction - delay_minutes, na.rm = T),
              MAE = mean(abs(Mean_Error), na.rm = T),
              SD_MAE = mean(abs(Mean_Error), na.rm = T)) %>%
  ungroup()



error.fold.time %>% 
   ggplot(aes(MAE)) + 
   geom_histogram(bins = 30, colour="black", fill = palette2[1]) +
   geom_vline(aes(xintercept = mean(MAE)), col = palette2[2], lwd=1) + 
   scale_x_continuous(breaks = seq(0, 3, by = 0.2)) + 
   labs(title="LOGO-CV of Train Delay Time by Day of the Week", 
        subtitle = "New Jersey Transit",
         x="Mean Absolute Error", y="Count",
        caption="Figure 4.6")+
   plotTheme()

```



```{r validation table, warning = FALSE, message = FALSE, fig.width=10}
# rbind(error.fold.space %>%
#       summarize(CrossValidation = "LOGO CV by station",
#                 Mean_MAE = round(mean(MAE), 2),
#                 SD_MAE = round(sd(MAE), 2)),
#       error.fold.time %>%
#       summarize(CrossValidation = "LOGO CV by day of the Week",
#                 Mean_MAE = round(mean(MAE), 3),
#                 SD_MAE = round(sd(MAE), 3))) %>%
#   kable(caption = "Table 4.2 LOGO-CV errors by station and day of week") %>%
#   kable_styling()


error.fold.time %>%
  summarize(CrossValidation = "LOGO CV by day of the Week",
                Mean_MAE = round(mean(MAE), 3),
                SD_MAE = round(sd(MAE), 3)) %>%
  kable(caption = "Table 4.4") %>%
  kable_styling()
```

<br />

<br />

## 5. Conclusion

Currently, the model predicts well (correctly for the majority of data) for delays under 20 minutes. Though our focus was not originally on being able to predict delays far in advance, our model can be applied as far in advance as needed. With more computing power, which would allow us to train on a wider range of dates, we could achieve higher accuracy for advance predictions.

As our prediction model is the basis of the Delay Estimator, refining it is crucial to developing a usable tool for both the New Jersey Transit app and for other transit agencies that would be interested in employing delay prediction data. To improve our current model, and especially predicting delays of over 20 minutes (where the model is weaker), an important step would be to research causes of severe train delays, then incorporating these factors as independent variables. We also need to incorporate factors that lessen the greater level of spatial Mean Absolute Error that the model currently has.

There are several future steps that would help to make the Delay Estimator more practically useful. As Amtrak runs in the same areas as NJ Transit, it would be useful to compare the delays between the two systems. To accomplish this, the next step would be to insert actual schedule times into the Kaggle data, enabling us to calculate delays and develop a prediction model. Since Amtrak is also heavy rail, using Amtrak data might also help improve accuracy and consistency for the NJ Transit model, through identifying common independent variables that relate to delay. Additionally, this dataset is currently limited to heavy rail in the New Jersey Transit system, so much of the delay on connectors for multi-leg trips is unavailable. Because light rail is somewhat similar to heavy rail in how it functions, it might be possible to apply the current model structure to light rail data. Buses, which are the other connectors between multi-leg rail trips, would also be desirable to predict delays for; however, as buses are far more susceptible to delay from a variety of factors, developing a predictive model for bus delay would be far more labor-intensive.
